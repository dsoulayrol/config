#!/usr/bin/env python
# sync_mail.py, a script to fetch and store mails.
# Copyright (C) 2009  David Soulayrol <david.soulayrol@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Add a ! symbol on imap boxes which are real sources of
#       messages. Other boxes should not be sorted.
"""
Usage: sync_mail.py [--user login]
                    [--imap user:pass@server{box, ...}]
                    [--pop user:pass@server]
"""

from __future__ import with_statement # This isn't required in Python 2.6

import contextlib
import errno
import logging
import mailbox
import os
import re
import subprocess
import sys
import tempfile


ISYNC_CONF_HEADER_PATTERN = """# -*- Generated by sync_mail.py -*-
#
# DO NOT EDIT!
#  Anyway, a new file is regenerated at each invocation. :)


# Global configuration section
#   Values here are used as defaults for any following Channel section that
#   doesn't specify them.
Expunge None
Create Both

# Local repository
MaildirStore Local
Path %s
Trash trash

"""

ISYNC_CONF_ACCOUNT_PATTERN = """# IMAP account
IMAPAccount %s
Host %s
User %s
Pass %s
RequireSSL no

IMAPStore %s
Account %s

"""

ISYNC_CONF_CHANNEL_PATTERN = """Channel %s
Master :%s:%s
Slave :Local:%s
Expunge Both

"""

FETCHMAIL_CONF_HEADER_PATTERN = """# -*- Generated by sync_mail.py -*-
#
# DO NOT EDIT!
#  Anyway, a new file is regenerated at each invocation. :)

set no bouncemail
set no spambounce
set properties ""

"""

FETCHMAIL_CONF_ACCOUNT_PATTERN = """
poll %s with proto POP3
       user '%s' there with password '%s' is '%s' here
       mda "/usr/bin/procmail"
       fetchall
"""


class LockError(Exception):
    """Exception raised on lock failure."""
    pass


def check_connection():
    proc = subprocess.Popen(
        ['ping', '-q', '-c1', 'google.com'],
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.wait()
    return proc.returncode == 0


def create_logger(name):
    pattern = '%(name)18s::%(lineno)-6s%(levelname)-10s%(message)s'
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter(pattern))
    logger.addHandler(handler)
    return logger


@contextlib.contextmanager
def flock(path):
    """A simple filelock implementation, using python context manager.

    Adapted from the nice snippet found on
    http://code.activestate.com/recipes/576572/
    """
    while True:
        try:
            fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_RDWR)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
            else:
                raise LockError
        else:
            break
    try:
        yield fd
    finally:
        os.unlink(path)


class MailboxStats(object):
    def __init__(self, path, name):
        self._name = name
        self._path = path
        self.new = 0
        self.unread = 0

    def __repr__(self):
        return self._name

    def __str__(self):
        return self.__repr__()

    name = property(lambda self: self._name)
    path = property(lambda self: self._path)


class MaildirWrapper(mailbox.Maildir, MailboxStats):
    def __init__(self, path, name):
        MailboxStats.__init__(self, path, name)
        mailbox.Maildir.__init__(self, path, create=False)


class MboxWrapper(mailbox.Maildir, MailboxStats):
    def __init__(self, path, name):
        MailboxStats.__init__(self, path, name)
        mailbox.Maildir.__init__(self, path, create=False)


class Account(object):
    def __init__(self, filename, folder):
        self._logger = create_logger(self.__class__.__name__)
        self._file = filename
        self._mailboxes = []
        self._parse(folder)

    def __repr__(self):
        return repr(self._mailboxes)

    def __str__(self):
        return self.__repr__()

    def _parse(self, folder):
        with open(self._file) as f:
            self._logger.info('parsing %s' % self._file)
            for line in f:
                if line.startswith('mailboxes'):
                    self._parse_mailbox(line[10:-1], folder)

    def _parse_mailbox(self, mb_name, folder):
        if mb_name.startswith('"'):
            mb_name = mb_name[1:-1]

        try:
            if mb_name.startswith('$folder/'):
                self._mailboxes.append(
                    self._generate_mailbox(folder, mb_name[8:]))
            elif mb_name[0] in ['=', '+']:
                self._mailboxes.append(
                    self._generate_mailbox(folder, mb_name[1:]))
            else:
                self._logger.warn('unknown mailbox format %s' % mb_name)
        except mailbox.NoSuchMailboxError:
            self._logger.error('non existent mailbox %s' % mb_name)

    def _generate_mailbox(self, folder, name):
        path = os.path.join(folder, name)
        if os.path.isdir(path):
            return MaildirWrapper(path, name)
        elif os.path.isfile(path):
            return MboxWrapper(path, name)
        else:
            raise mailbox.NoSuchMailboxError

    mailboxes = property(lambda self: self._mailboxes)


class MuttConfiguration(object):
    def __init__(self):
        self._logger = create_logger(self.__class__.__name__)
        for arg in sys.argv:
            if arg.startswith('--user='):
                self._user = arg[7:]

        if not '_user' in self.__dict__:
            if os.environ.has_key('USER'):
                self._user = os.environ['USER']
            elif os.environ.has_key('LOGNAME'):
                self._user = os.environ['LOGNAME']

        if not len(self._user):
            self._logger.error('no user name.')
            raise ValueError('no user name')

        self._root_path = os.path.join('/home', self._user)
        self._accounts = []
        self._folder = os.path.join(self._root_path, 'Mail')

    def parse(self):
        """Mutt configuration parser.

        This parser looks for folder settings in ~login/.mutt/muttrc
        and mailboxes setting in ~login/.mutt/accounts/*. It is not
        smart enough to distinguish hooks and it will happily
        aggregate any matching lines.
        """
        self._parse_muttrc(os.path.join(self._root_path, '.mutt/muttrc'))
        self._parse_accounts(os.path.join(self._root_path, '.mutt/accounts'))

    def _parse_muttrc(self, path):
        with open(path) as f:
            self._logger.info('parsing %s' % path)
            pattern = re.compile(
                '^set folder\s*=\s*\"?(?P<value>~?[/\w]+)\"?')
            for line in f:
                m = pattern.match(line)
                if m:
                    self._folder = m.group('value')
                    self._folder = self._folder.replace('~', self._root_path)
                    self._logger.debug('folder set to %s' % self._folder)
                    return

    def _parse_accounts(self, path):
        for f in os.listdir(path):
            if f.endswith('~'):
                self._logger.debug('ignore emacs backup %s' % f)
                continue
            self._accounts.append(Account(os.path.join(path, f), self._folder))

    user = property(lambda self: self._user)
    accounts = property(lambda self: self._accounts)
    folder = property(lambda self: self._folder)


class IMAPSynchroniser(object):
    """A simple wrapper around isync.

    The IMAPSynchroniser is able to build a isync configuration file on
    the fly and execute it. Configuration file is built using the
    --imap arguments to the program. There can be any of
    them. Configuration is stored in a temporary file, so an existing
    configuration will be safe.
    """
    def __init__(self, conf):
        self._logger = create_logger(self.__class__.__name__)
        self._mutt_conf = conf
        self._isync_conf = self._build_configuration()

    def run(self):
        self._logger.info('synchronising boxes ...')
        conf_filename = self._flush_configuration()
        proc = subprocess.Popen(
            ['mbsync', '-c', conf_filename, '-a'],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        status_re = re.compile(
            '^Selecting (?P<side>\w+) (?P<name>.+)\.\.\. (?P<msg>\d+) messages, (?P<new>\d+) recent')
        current_pair = {}
        line = proc.stdout.readline()
        while line != '':
            # TODO: improve reporting
            self._logger.debug('  (isync: ' + line[:-1] + ')')
            m = status_re.match(line)
            if m:
                current_pair[m.group('side')] = m.group('name')
            if len(current_pair) == 2:
                self._log_status(current_pair['slave'], current_pair['master'])
                current_pair = {}
            line = proc.stdout.readline()

        proc.wait()
        os.unlink(conf_filename)

    def _build_configuration(self):
        """Parse imap arguments on the command line to create the configuration.

        The configuratioin is built with following prerequisites in
        mind.

        The local mail image is named after the domain name of
        the server and the lowered mailbox. For example,
        imap.gmail.com/INBOX is mapped to gmail.inbox.

        The local store path is determined using the mutt
        configuration. Currently, the folder input is used.

        Channels are named after the server and the mailbox name.

        The builder does not support SSL.
        """
        # Trailing slash is very important in Path!
        root_path = self._mutt_conf.folder
        if not root_path.endswith('/'): root_path += '/'
        conf = ISYNC_CONF_HEADER_PATTERN % root_path

        pattern = re.compile(
            '^(?P<user>\w+):(?P<pass>\w+)@(?P<server>[\.\w]+){(?P<boxes>[\w,]+)}')
        for arg in (e for e in sys.argv if e.startswith('--imap=')):
            m = pattern.match(arg[7:])
            if m:
                server = m.group('server')
                account = server.split('.')[-2].capitalize()
                conf += ISYNC_CONF_ACCOUNT_PATTERN % (
                    account, server, m.group('user'), m.group('pass'), account, account)

                for mailbox in m.group('boxes').split(','):
                    channel = '.'.join([account, mailbox.capitalize()])
                    conf += ISYNC_CONF_CHANNEL_PATTERN % (
                        channel, account, mailbox, channel.lower())
        return conf

    def _flush_configuration(self):
        fd, name = tempfile.mkstemp(prefix='isync.')
        os.write(fd, self._isync_conf)
        os.close(fd)
        self._logger.debug('flushed isync configuration into %s' % name)
        return name

    def _log_status(self, local, distant):
        self._logger.info('  %s <==> %s' % (local, distant))


class POPFetcher(object):
    """A simple wrapper around fetchmail.

    The POPFetcher is able to build a fetchmail configuration file on
    the fly and execute it. Configuration file is built using the
    --pop arguments to the program. There can be any of
    them. Configuration is stored in a temporary file, so an existing
    configuration will be safe.
    """
    def __init__(self, conf):
        self._logger = create_logger(self.__class__.__name__)
        self._mutt_conf = conf
        self._fetchmail_conf = self._build_configuration()

    def run(self):
        self._logger.info('fetching pop accounts ...')
        conf_filename = self._flush_configuration()
        proc = subprocess.Popen(
            ['fetchmail', '-f', conf_filename],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        line = proc.stdout.readline()
        while line != '':
            self._logger.debug('  (fetchmail: ' + line[:-1] + ')')
            line = proc.stdout.readline()
        proc.wait()
        os.unlink(conf_filename)

    def _build_configuration(self):
        """Parse pop arguments on the command line to create the configuration.
        """
        conf = FETCHMAIL_CONF_HEADER_PATTERN
        pattern = re.compile(
            '^(?P<user>[\.@\w]+):(?P<pass>\w+)@(?P<server>[\.\w]+)')
        for arg in (e for e in sys.argv if e.startswith('--pop=')):
            m = pattern.match(arg[6:])
            if m:
                conf += FETCHMAIL_CONF_ACCOUNT_PATTERN % (
                    m.group('server'), m.group('user'), m.group('pass'),
                    self._mutt_conf.user)
        return conf

    def _flush_configuration(self):
        fd, name = tempfile.mkstemp(prefix='fetchmail.')
        os.write(fd, self._fetchmail_conf)
        os.close(fd)
        self._logger.debug('flushed fetchmail configuration into %s' % name)
        return name


class MailHandler(object):
    """A tool to sort and inspect mailboxes."""
    # TODO: port this class to the mailbox standard API. Will allow to
    #       distinguish unread from unseen mails, and parse mbox.

    # TODO: ensure that already sorted mail do not get
    #       resorted. Perhaps will it be simple with mailbox
    #       module. Or use a timestamp.
    def __init__(self, conf):
        self._logger = create_logger(self.__class__.__name__)
        self._conf = conf

    def sort(self):
        self._logger.info('sorting new mail ...')

        # First take a snapshot of new mails on every mailbox to be
        # sure they will be handled only once.
        for box, mails in self._snapshot(self._conf.accounts).iteritems():
            self._logger.info('sorting %s ...' % box)
            for mail in mails:
                proc = subprocess.Popen(
                    'procmail',
                    stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                try:
                    with open(os.path.join(box.path, 'new', mail)) as f:
                        proc.communicate(f.read())
                        if proc.returncode == 0:
                            self._logger.info('sorted %s' % mail)
                            os.unlink(os.path.join(box.path, 'new', mail))
                        else:
                            self._logger.info('requeued %s !' % mail)
                except (OSError, IOError):
                    # It is possible the message was already
                    # edited through mutt, specially with
                    # spamassassin which is *very* slow :)
                    self._logger.warn('could not unlink %s' % mail)

    def notify(self):
        """Notify the user using dbus.

        Note that if this script must be run by cron, it does not have
        any access to the variable environment which holds the DBus
        session address (DBUS_SESSION_BUS_ADDRESS). In such a case, it
        can be useful to execute a short script on session startup to
        store this information so it can be sourced in the cron job.

        Here is a script which would do the trick.

        #!/bin/sh

        # Export the dbus session address on startup so it can be used by cron
        #  (see http://earlruby.org/2008/08/update-pidgin-status-using-cron/)
        FILE=$HOME/.config/dbus_session

        touch $FILE
        chmod 600 $FILE
        env | grep DBUS_SESSION_BUS_ADDRESS > $FILE
        echo 'export DBUS_SESSION_BUS_ADDRESS' >> $FILE

        And here is a cron job sample, which calls this script every
        five minutes.

        */5 * * * * source ~/.config/dbus_session; ~/bin/sync_mail.py > ~/mail.log
        """
        if not os.environ.has_key('DBUS_SESSION_BUS_ADDRESS'):
            self._logger.warn('DBus session not available')
            return

        try:
            import dbus
        except ImportError:
            self._logger.warn('dbus module is not installed')
            return

        bus = dbus.SessionBus()

        stats = {}
        for box, mails in self._snapshot(self._conf.accounts).iteritems():
            stats[box.name] = [len(mails), 0, 0]

        try:
            self._notify_mail_app(bus, stats)
            self._logger.info('notification sent to mail app')
        except dbus.exceptions.DBusException, e:
            self._logger.error('delivery to mail app failed')
            self._notify_desktop(dbus, bus, stats)
            self._logger.info('notification sent to desktop')

    def _notify_mail_app(self, bus, stats):
        obj = bus.get_object('net.soulayrol.MailNotifier',
                             '/net/soulayrol/MailNotifier')
        m = obj.get_dbus_method('notify', 'net.soulayrol.MailNotifier')
        m(stats)

    def _notify_desktop(self, dbus, bus, stats):
        message = ''
        for box, counts in stats.iteritems():
            if counts[0] > 0:
                message += '%d new messages in %s. %s old. Total: %s\n' % (
                    counts[0], box, counts[1], counts[2])

        obj = bus.get_object('org.freedesktop.Notifications',
                             '/org/freedesktop/Notifications')
        itf = dbus.Interface(obj, 'org.freedesktop.Notifications')
        itf.Notify(
            'sync_mail.py', 0, '', 'New Mail!', message, [], {}, -1)

    def _snapshot(self, accounts):
        snapshot = {}
        for account in accounts:
            for box in account.mailboxes:
                path = os.path.join(box.path, 'new')
                if os.path.isdir(path):
                    snapshot[box] = os.listdir(path)
                else:
                    self._logger.warn(
                        '%s (%s) is not a valid maildir box ' % (box, box.path))
        return snapshot


# Main functions

def start_sync():
    # if not check_connection():
    #     logger.error('no available connection.')
    #     sys.exit(1)

    # Install lock.
    try:
        logger = create_logger(__name__)

        with flock(os.path.join(os.environ['HOME'], '.sync_mail.lock')):

            # Read the Mutt configuration to get a single configuration source.
            mutt_conf = MuttConfiguration()
            mutt_conf.parse()

            # Synchronize IMAP accounts.
            IMAPSynchroniser(mutt_conf).run()

            # Fetch distant POP accounts.
            POPFetcher(mutt_conf).run()

            # Sort incoming mail
            mail_handler = MailHandler(mutt_conf)
            mail_handler.sort()

            # Count new mails and notify the user through dbus.
            mail_handler.notify()

    except OSError, e:
        logger.error('Lock error: %s' % e)
    except LockError:
        logger.error('Another instance is already running.')

if __name__ == '__main__':
    start_sync()
